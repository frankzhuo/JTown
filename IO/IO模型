同步：
    如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行；
异步：
    如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。

阻塞：
    当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；

非阻塞：
    当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。

-------------------------------------------------------------------------------------------------------------------
当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪:
    阻塞IO:
        对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；

    非阻塞IO:
        对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。

当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：
            1）查看数据是否就绪；
            2）进行数据拷贝（内核将数据拷贝到用户线程）。
    那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。

Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；
而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。

同步IO:
    如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；
    当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程；

异步IO：
    如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。
    只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。
    也就是说在异步IO中，不会对用户线程产生任何阻塞。

同步IO和异步IO的关键区别：
    数据拷贝阶段是由用户线程完成还是内核完成。
    所以说异步IO必须要有操作系统的底层支持。

同步IO和异步IO与阻塞IO和非阻塞IO是不同的两组概念。
    阻塞IO和非阻塞IO是反映在当用户请求IO操作时，如果数据没有就绪，是用户线程一直等待数据就绪，还是会收到一个标志信息这一点上面的。
    也就是说，阻塞IO和非阻塞IO是反映在IO操作的第一个阶段，在查看数据是否就绪时是如何处理的。

五种IO模型：
    阻塞IO模型
    非阻塞IO模型
    多路复用IO模型
    信号驱动IO模型
    异步IO模型

传统经典网络服务设计模式：
    多线程
    线程池    

两种高性能IO设计模式
    Reactor
        会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询。
        多路复用IO就是采用Reactor模式

    Proactor
        当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成。
        异步IO模型采用的就是Proactor模式。