定义
    分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。
    简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。
    本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

分布式事务的产生的原因
    数据库分库分表
        当数据库单表一年产生的数据超过1000W，那么就要考虑分库分表，具体分库分表简单的说就是原来的一个数据库变成了多个数据库。
        这时候，如果一个操作既访问01库，又访问02库，而且要保证数据的一致性，那么就要用到分布式事务。

    应用SOA化（服务化）
        所谓的SOA化，就是业务的服务化。比如原来单机支撑了整个电商网站，现在对整个网站进行拆解，分离出了订单中心、用户中心、库存中心。
        对于订单中心，有专门的数据库存储订单信息，用户中心也有专门的数据库存储用户信息，库存中心也会有专门的数据库存储库存信息。
        这时候如果要同时对订单和库存进行操作，那么就会涉及到订单数据库和库存数据库，为了保证数据一致性，就需要用到分布式事务。

    以上两种情况表象不同，但是本质相同，都是因为要操作的数据库变多了！


事务的ACID特性
    原子性（A）
        所谓的原子性就是说，在整个事务中的所有操作，要么全部完成，要么全部不做，没有中间状态。
        对于事务在执行中发生错误，所有的操作都会被回滚，整个事务就像从没被执行过一样。

    一致性（C）
        事务的执行必须保证系统的一致性，就拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。

    隔离性（I）
        所谓的隔离性就是说，事务与事务之间不会互相影响，一个事务的中间状态不会被其他事务感知。

    持久性（D）
        所谓的持久性，就是说一单事务完成了，那么事务对数据所做的变更就完全保存在了数据库中，即使发生停电，系统宕机也是如此。

分布式事务的应用场景
    支付
        最经典的场景就是支付了，一笔支付，是对买家账户进行扣款，同时对卖家账户进行加钱，这些操作必须在一个事务里执行，要么全部成功，要么全部失败。
        而对于买家账户属于买家中心，对应的是买家数据库，而卖家账户属于卖家中心，对应的是卖家数据库，对不同数据库的操作必然需要引入分布式事务。

    在线下单
        买家在电商平台下单，往往会涉及到两个动作，一个是扣库存，第二个是更新订单状态，库存和订单一般属于不同的数据库，需要使用分布式事务保证数据一致性。

常见的分布式事务解决方案：
    基于XA协议的两阶段提交
        XA是一个分布式事务协议，由Tuxedo提出。
        XA中大致分为两部分：
            事务管理器
                作为全局的调度者，负责各个本地资源的提交和回滚。
            本地资源管理器
                往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口.
        总的来说，XA协议比较简单，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。
        但是，XA也有致命的缺点，那就是性能不理想，特别是在交易下单链路，往往并发量很高，XA无法满足高并发场景。
        XA目前在商业数据库支持的比较理想，在mysql数据库中支持的不太理想，mysql的XA实现，没有记录prepare阶段日志，主备切换回导致主库与备库数据不一致。
        许多nosql也没有支持XA，这让XA的应用场景变得非常狭隘。

    本地消息表，异步扫表触发，异步确保（最终一致性）  推荐的方案！
        （该方案易于理解，并且变相将分布式事务分拆为本地事务，很巧妙。但比下面的消息事务要落后一些，因为要单独维护一张消息表，增加了维护成本）
        本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理，这种思路是来源于ebay。
        基本思路就是：
            消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。
            消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。
            生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。
            如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。

        这种方案遵循BASE理论，采用的是最终一致性，笔者认为是这几种方案里面比较适合实际业务场景的。
        既不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。

        优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。
        缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。

    消息事务，利用MQ的事务消息支持功能（最终一致性）   更推荐的方案！
        所谓的消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功成功并且对外发消息成功，要么两者都失败。
            开源的RocketMQ就支持这一特性，具体原理如下：
            1、A系统向消息中间件发送一条预备消息
            2、消息中间件保存预备消息并返回成功
            3、A执行本地事务
            4、A发送提交消息给消息中间件

        通过以上4步完成了一个消息事务。对于以上的4个步骤，每个步骤都可能产生错误，下面一一分析：
        步骤一出错，则整个事务失败，不会执行A的本地操作
        步骤二出错，则整个事务失败，不会执行A的本地操作
        步骤三出错，这时候需要回滚预备消息，怎么回滚？答案是A系统实现一个消息中间件的回调接口，消息中间件会去不断执行回调接口，检查A事务执行是否执行成功，如果失败则回滚预备消息
        步骤四出错，这时候A的本地事务是成功的，那么消息中间件要回滚A吗？答案是不需要，其实通过回调接口，消息中间件能够检查到A执行成功了，这时候其实不需要A发提交消息了，消息中间件可以自己对消息进行提交，从而完成整个消息事务。

        基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+B系统的本地操作。
        其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。
        虽然上面的方案能够完成A和B的操作，但是A和B并不是严格一致的，而是最终一致的，我们在这里牺牲了一致性，换来了性能的大幅度提升。
        当然，这种玩法也是有风险的，如果B一直执行不成功，那么一致性会被破坏，具体要不要玩，还是得看业务能够承担多少风险。

        有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。
        以阿里的 RocketMQ 中间件为例，其思路大致为：
            第一阶段Prepared消息，会拿到消息的地址。
            第二阶段执行本地事务，
            第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。

        也就是说在业务方法内要向消息队列提交两次请求，一次发送消息和一次确认消息。
        如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。

        优点： 实现了最终一致性，不需要依赖本地数据库事务。
        缺点： 实现难度大，主流MQ不支持，没有.NET客户端，RocketMQ事务消息部分代码也未开源。

    补偿事务（TCC）
        所谓的TCC编程模式，也是两阶段提交的一个变种。
        TCC提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm和Cancel三个操作。
        以在线下单为例，Try阶段会去扣库存，Confirm阶段则是去更新订单状态，如果更新订单失败，则进入Cancel阶段，会去恢复库存。
        总之，TCC就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，复杂度也不一样，因此，这种模式并不能很好地被复用。

        TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。
        它分为三个阶段：
            Try 阶段主要是对业务系统做检测及资源预留
            Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
            Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。

        举个例子，假入 Bob 要向 Smith 转账，思路大概是：
            我们有一个本地方法，里面依次调用
            1、首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。
            2、在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。
            3、如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。

        优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些
        缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。

    Sagas 事务模型
        Saga事务模型又叫做长时间运行的事务（Long-running-transaction）, 它是由普林斯顿大学的H.Garcia-Molina等人提出，它描述的是另外一种在没有两阶段提交的的情况下解决分布式系统中复杂的业务事务问题。
        我们这里说的是一种基于 Sagas 机制的工作流事务模型，这个模型的相关理论目前来说还是比较新的，以至于百度上几乎没有什么相关资料。
        该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由 Sagas 工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么Sagas工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。
        比如我们一次关于购买旅游套餐业务操作涉及到三个操作，他们分别是预定车辆，预定宾馆，预定机票，他们分别属于三个不同的远程接口。可能从我们程序的角度来说他们不属于一个事务，但是从业务角度来说是属于同一个事务的。
        他们的执行顺序如上图所示，所以当发生失败时，会依次进行取消的补偿操作。
        因为长事务被拆分了很多个业务流，所以 Sagas 事务模型最重要的一个部件就是工作流或者你也可以叫流程管理器（Process Manager），工作流引擎和Process Manager虽然不是同一个东西，但是在这里，他们的职责是相同的。在选择工作流引擎之后，最终的代码也许看起来是这样的

            SagaBuilder saga = SagaBuilder.newSaga("trip")
                    .activity("Reserve car", ReserveCarAdapter.class) 
                    .compensationActivity("Cancel car", CancelCarAdapter.class) 
                    .activity("Book hotel", BookHotelAdapter.class) 
                    .compensationActivity("Cancel hotel", CancelHotelAdapter.class) 
                    .activity("Book flight", BookFlightAdapter.class) 
                    .compensationActivity("Cancel flight", CancelFlightAdapter.class) 
                    .end()
                    .triggerCompensationOnAnyError();

            camunda.getRepositoryService().createDeployment() 
                    .addModelInstance(saga.getModel()) 
                    .deploy();

        优缺点这里我们就不说了，因为这个理论比较新，目前市面上还没有什么解决方案，即使是 Java 领域，我也没有搜索的太多有用的信息。

总结
    分布式事务，本质上是对多个数据库的事务进行统一控制，按照控制力度可以分为：不控制、部分控制和完全控制。
    不控制就是不引入分布式事务，部分控制就是各种变种的两阶段提交，包括上面提到的消息事务+最终一致性、TCC模式，而完全控制就是完全实现两阶段提交。
    部分控制的好处是并发量和性能很好，缺点是数据一致性减弱了。
    完全控制则是牺牲了性能，保障了一致性。
    具体用哪种方式，最终还是取决于业务场景。
    作为技术人员，一定不能忘了技术是为业务服务的，不要为了技术而技术，针对不同业务进行技术选型也是一种很重要的能力！

扩展：
    目前分布式事务最终一致性比较多的解决方案有几个：
        一、结合MQ消息中间件实现的可靠消息最终一致性
                可靠消息最终一致性，需要业务系统结合MQ消息中间件实现，在实现过程中需要保证消息的成功发送及成功消费。即需要通过业务系统控制MQ的消息状态。

        二、TCC补偿性事务解决方案
                TCC补偿性，分为三个阶段TRYING-CONFIRMING-CANCELING。每个阶段做不同的处理。
                TRYING阶段主要是对业务系统进行检测及资源预留
                CONFIRMING阶段是做业务提交，通过TRYING阶段执行成功后，再执行该阶段。默认如果TRYING阶段执行成功，CONFIRMING就一定能成功。
                CANCELING阶段是回对业务做回滚，在TRYING阶段中，如果存在分支事务TRYING失败，则需要调用CANCELING将已预留的资源进行释放。
                
        三、最大努力通知型方案
                这种方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。
                这种方案也是结合MQ进行实现，例如：通过MQ发送http请求，设置最大通知次数。达到通知次数后即不再通知。