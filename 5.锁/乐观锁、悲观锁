乐观锁 VS 悲观锁
    乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。

    概念
        悲观锁
            悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。
            悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
            Java中，synchronized关键字和Lock的实现类都是悲观锁。
        乐观锁
            乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。
            乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。
            如果这个数据没有被更新，当前线程将自己修改的数据成功写入。
            如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。
            乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法。
            Java原子类（AtomicXXX类）中的递增操作就通过CAS自旋实现的。

    适用场景
        悲观锁
            写多读少的场景
            先加锁可以保证写操作时数据正确。

        乐观锁
            读多写少的场景
            不加锁的特点能够使其读操作的性能大幅提升。





