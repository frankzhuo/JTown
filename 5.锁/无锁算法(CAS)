无锁算法
    定义
        在不使用锁的情况下实现多线程之间的变量同步。
    好处
        没有线程被阻塞，线程运行效率大幅提升。
        无阻塞编程，效率就是高
    典型的算法
        CAS
            是一种无锁算法。
            全称Compare And Swap，中文名：比较与交换
            假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。
            当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。
    典型算法的实际应用
        java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。
        各种AtomicXXX类的底层都是CAS算法作为支撑。
    CAS算法涉及到三个操作数：
        需要读写的内存值 V。
        进行比较的值 A。
        要写入的新值 B。
    CAS算法的更新逻辑：
        当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。
        一般情况下，“更新”是一个不断重试(自旋)的操作。

CAS的问题： 
    1.ABA问题。
        CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。
        但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路：
            在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
        解决方案：
            JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。
            compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。

    2.循环时间长开销大。
        CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。

    3.只能保证一个共享变量的原子操作。
        对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
        解决方案：
            Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。
