接口安全性4大机制：
    Token（凭证、令牌，只为授权用户提供定向服务）
        通常是UUID，登录后将Token-UserId以键值对的形式存放在缓存服务器中。
        每次验证Token，若不存在或为空，则请求无效。
        对于APP这种无登录使用的安全场景，服务端可根据deviceId来分配token。
        一种典型的Token的是session机制（基于cookie实现）

    Timestamp(时间戳，防DOS和爬虫)
        用户每次请求都带上当前时间的时间戳timestamp，服务端接收到timestamp后跟当前时间进行比对，如果时间差大于一定时间（比如5分钟），则认为该请求失效。
        时间戳超时机制是防御DOS攻击的有效手段。
        为避免时区不一致的问题，可统一使用0时区来进行对齐。
        如果本地修改了时间，可以提供一个服务器对时的机制，在请求之前先获取服务器时间，当然这只是对小部分用户。

    Sign（签名，加验签，保证信息不被篡改）
        将Token和时间戳加上其他请求参数再用MD5或SHA-1算法（可根据情况加盐，盐要小心保存避免泄露）加密。
        加密后的数据就是本次请求的签名sign，服务端接收到请求后以同样的算法得到签名，并跟当前的签名进行比对，如果不一样，说明参数被更改过，直接返回错误标识。
        签名机制保证了数据不会被篡改。

    幂等校验（拒绝重复调用，非必须）：
        客户端第一次访问时，将签名sign存放到缓存服务器中，超时时间设定为跟时间戳的超时时间一致，二者时间一致可以保证无论在timestamp限定时间内还是外URL都只能访问一次。
        如果有人使用同一个URL再次访问，如果发现缓存服务器中已经存在了本次签名，则拒绝服务。
        如果在缓存中的签名失效的情况下，有人使用同一个URL再次访问，则会被时间戳超时机制拦截。
        这就是为什么要求时间戳的超时时间要设定为跟时间戳的超时时间一致。
        拒绝重复调用机制确保URL被别人截获了也无法使用（如抓取数据）。

扩展：
    过载保护：
        对接口访问频率设置一定阈值，对超过阈值的请求进行屏蔽及预警。
    异常封装：
        服务端需要构建异常统一处理框架，将服务可能出现的异常做统一封装，返回固定的code与msg，防止程序堆栈信息暴露。
    HTTPS：
        HTTPS能够有效防止中间人攻击，有效保证接口不被劫持，对数据窃取篡改做了安全防范。但HTTP升级HTTPS会带来更多的握手，而握手中的运算会带来更多的性能消耗。
        这也是不得不考虑的问题。

整个流程如下：
    1、客户端通过用户名密码登录服务器并获取Token
    2、客户端生成时间戳timestamp，并将timestamp作为其中一个参数
    3、客户端将所有的参数，包括Token和timestamp按照自己的算法进行排序加密得到签名sign
    4、将token、timestamp和sign作为请求时必须携带的参数加在每个请求的URL后边（http://url/request?token=123&timestamp=123&sign=123123123）
    5、服务端写一个过滤器对token、timestamp和sign进行验证，只有在token有效、timestamp未超时、缓存服务器中不存在sign三种情况同时满足，本次请求才有效。

签名算法防泄露：
    1.安卓
        jni算法
    2.web前端
        https
        签名，前提是js混淆，但安全性依然不足

利弊分析：
    利：
        安全性增加
    
    弊：
        所有安全措施全用上的话会过于复杂

    权衡：
        根据实际项目情况和接口安全性要求，对4大基本机制进行裁剪和组合。