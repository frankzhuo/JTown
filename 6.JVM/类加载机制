类加载机制
    类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法去内，
    然后在堆区创建一个java.lang.Class对象，用来封装在方法区内的数据结构。
    类的加载最终是在堆区内的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

类加载有三种方式：
    1）命令行启动应用时候由JVM初始化加载
    2）通过Class.forName（）方法动态加载
    3）通过ClassLoader.loadClass（）方法动态加载

双亲委派模型（Parent Delegation Model）？
    类的加载过程采用双亲委派机制，这种机制能更好的保证 Java 平台的安全性
    类加载器 ClassLoader 是具有层次结构的，也就是父子关系，其中，Bootstrap 是所有类加载器的父亲。
    该模型要求除了顶层的 Bootstrap class loader 启动类加载器外，其余的类加载器都应当有自己的父类加载器。
    子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。
    每个类加载器都有自己的命名空间。
    在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；
    在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。

双亲委派模型的工作过程？
    1.当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。
    每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。
    2.当前 ClassLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.
    当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。

为何这样设计？
    主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String。
    同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException.


类加载器：
    BootStrap ClassLoader
        启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等。

    Extension ClassLoader
        扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。

    App ClassLoader
        系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件

    自定义类加载器
        
        
