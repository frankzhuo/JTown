JVM常见3大垃圾回收算法
    1）标记-清除算法：
        标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

        优点：
            简单
        缺点：
            容易造成内存碎片

    2）复制算法：
        将可用内存按容量划分为大小相等的两块。
        在任意时间点，所有动态分配的对象都只能分配在其中一个区间（称为活动区间），而另外一个区间（称为空闲区间）则是空闲的。
        当活动区间内存用完时，JVM将暂停程序运行，开启复制算法GC线程。
        接下来GC算法会将活动区域内的存活对象全部复制到空闲区间，然后原有的活动区间将被清空。

        优点：
            算法简单
            复制的过程中自动解决了内存碎片问题。

        缺点：
            浪费一半内存
            若对象存活率较高，则复制、更新对象引用地址将变得无意义、白白浪费时间和cpu资源。

    3）标记-整理算法：
        标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所一端移动，然后直接清理掉端边界以外的内存。

        优点：
            解决内存碎片问题
            不浪费内存

        缺点：
            复杂度高于前两者
            因此效率低于复制算法

----------------------------------------------------------------------------------------------------------------
三个算法的共同点：
    1、三个算法都基于根搜索算法去判断一个对象是否应该被回收，而支撑根搜索算法可以正常工作的理论依据，就是语法中变量作用域的相关内容。
        因此，要想防止内存泄露，最根本的办法就是掌握好变量作用域，而不应该使用前面内存管理杂谈一章中所提到的C/C++式内存管理方式。

    2、在GC线程开启时，或者说GC过程开始时，它们都要暂停应用程序（stop the world）。
        它们的区别:（>表示前者要优于后者，=表示两者效果一样）

        效率：
            复制算法>标记/整理算法>标记/清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。

        内存整齐度：
            复制算法=标记/整理算法>标记/清除算法。

        内存利用率：
            标记/整理算法=标记/清除算法>复制算法。

        可以看到标记/清除算法是比较落后的算法了，但是后两种算法却是在此基础上建立的，俗话说“吃水不忘挖井人”，因此各位也莫要忘记了标记/清除这一算法前辈。
        而且，在某些时候，标记/清除也会有用武之地。

-----------------------------------------------------------------------------------------------------------------
    4）分代收集算法：
        一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。
        新生代都发现有大批对象死去，选用复制算法。
        老年代中因为对象存活率高，必须使用“标记-清除”或“标记-整理”算法来进行回收。

G1收集器
    简介：
        Garbage-First（G1，垃圾优先）收集器是服务类型的收集器，目标是多CPU、大内存机器。
        它高度符合垃圾收集暂停时间的目标，同时实现高吞吐量。
        Oracle JDK 7 update 4 以及更新发布版完全支持G1垃圾收集器

    G1的内存划分方式：
        它是将堆内存划分为多个大小相等的 heap 区,每个heap区都是逻辑上连续的一段内存(virtual memory)。
        其中一部分区域被当成老一代收集器相同的角色(eden, survivor, old), 但每个角色的区域个数都不是固定的。
        这在内存使用上提供了更多的灵活性。
