线程之间是如何通信的？
    Object类中wait()、notify()、notifyAll()
    Condition的await()、signal()、signalAll（）
    阻塞队列BlockingQueue就是为线程之间共享数据而设计的

==================================================================================================
    Object
        wait()
            调用某个对象的wait()方法能让当前线程阻塞，当前线程获得此对象的monitor（即锁）

        notify()
            调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能（随机）唤醒其中一个线程

        notifyAll()
            唤醒所有正在等待这个对象的monitor的线程

    ReentrantLock（重入锁）
        Condition.await()
            对应Object的wait()

        Condition.signal()
            对应Object的notify()

        Condition.signalAll()
            对应Object的notifyAll()
==================================================================================================
为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？
    Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。
    在Java的线程中并没有可供任何对象使用的锁和同步器。
    这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法

为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？
    当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。
    同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。
    由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。    

为什么Thread类的sleep()和yield()方法是静态的？
    因为Thread类的sleep()和yield()方法只能在当前正在执行的线程上运行。
    所以在其他处于等待状态的线程上调用这些方法是没有意义的，这就是为什么这些方法是静态的。
    它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。

如何dump一个thread？
    用jstack        

java中用到的线程调度算法是什么
    抢占式。
    一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

Thread.sleep(0)的作用是什么
    由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况。
    为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。













