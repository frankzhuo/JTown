线程之间是如何通信的？
    Object类中wait()、notify()、notifyAll()
    Condition的await()、signal()、signalAll（）
    阻塞队列BlockingQueue就是为线程之间共享数据而设计的

==================================================================================================
    Object
        wait()
            调用某个对象的wait()方法能让当前线程阻塞，当前线程获得此对象的monitor（即锁）

        notify()
            调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能（随机）唤醒其中一个线程

        notifyAll()
            唤醒所有正在等待这个对象的monitor的线程

    ReentrantLock（重入锁）
        Condition.await()
            对应Object的wait()

        Condition.signal()
            对应Object的notify()

        Condition.signalAll()
            对应Object的notifyAll()
==================================================================================================
为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？
    Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。
    在Java的线程中并没有可供任何对象使用的锁和同步器。
    这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法

为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？
    当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。
    同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。
    由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。    

为什么Thread类的sleep()和yield()方法是静态的？
    因为Thread类的sleep()和yield()方法只能在当前正在执行的线程上运行。
    所以在其他处于等待状态的线程上调用这些方法是没有意义的，这就是为什么这些方法是静态的。
    它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。

如何dump一个thread？
    用jstack        

java中用到的线程调度算法是什么
    抢占式。
    一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

Thread.sleep(0)的作用是什么
    由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况。
    为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。


有哪些多线程开发良好的实践?
    给线程命名
    最小化同步范围
    优先使用volatile
    尽可能使用更高层次的并发工具而非wait()和notify()来实现线程通信，如BlockingQueue、Semeaphore
    优先使用并发容器而非同步容器
    考虑使用线程池

volatile能使得一个非原子操作变成原子操作吗?
    一个典型的例子是在类中有一个 long 类型的成员变量。
    如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？
    因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。
    但是对一个 volatile 型的 long 或 double 变量的读写是原子。

    一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。

volatile类型变量提供什么保证?
    volatile 主要有两方面的作用:1.避免指令重排2.可见性保证。
    例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。
    volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。
    某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的(低32位和高32位)，但 volatile 类型的 double 和 long 就是原子的。






