内存模型
    Java内存模型规定，对于多个线程共享的变量，存储在主内存当中，每个线程都有自己独立的工作内存，线程只能访问自己的工作内存，不可以访问其它线程的工作内存。
    工作内存中保存了主内存共享变量的副本，线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步回到主内存当中。

如何保证多个线程操作主内存的数据完整性是一个难题，Java内存模型也规定了工作内存与主内存之间交互的协议，首先是定义了8种原子操作：
    lock:将主内存中的变量锁定，为一个线程所独占
    unclock:将lock加的锁定解除，此时其它的线程可以有机会访问此变量
    read:将主内存中的变量值读到工作内存当中
    load:将read读取的值保存到工作内存中的变量副本中。
    use:将值传递给线程的代码执行引擎
    assign:将执行引擎处理返回的值重新赋值给变量副本
    store:将变量副本的值存储到主内存中。
    write:将store存储的值写入到主内存的共享变量当中。

java中的++操作符线程安全么?
    不是线程安全的操作。
    它涉及到多个指令，如读取变量值、增加，然后存储回内存，这个过程可能会出现多个线程交差。


    