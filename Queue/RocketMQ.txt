发布订阅

消息优先级（变通的方式）
    优先级高的队列、优先级中的队列、优先级低的队列、...根据实际需要定若干个级别
    每个优先级可以用不同的topic表示，发消息时，指定不同的topic来表示优先级，这种方式可以解决绝大部分的优先级问题，但是对业务的优先级精确性做了妥协。

消息顺序性

消息过滤
    服务端过滤
        根据消息类型、语法表达式、Message Tag、Message Header、Message body等方式进行过滤。但会增加服务端负担

    客户端过滤
        由应用自定义实现,但会多收无用消息

消息持久化
    几种持久化方式：
        持久化到数据库，例如Mysql。
        持久化到KV存储，例如levelDB、伯克利DB等KV存储系统。
        文件记录形式持久化，例如Kafka，RocketMQ
        对内存数据做一个持久化镜像，例如beanstalkd，VisiNotify
    分析：
        (1)、(2)、(3)三种持久化方式都具有将内存队列Buffer进行扩展的能力，
        (4)只是一个内存的镜像，作用是当Broker挂掉重启后仍然能将之前内存的数据恢复出来。

    RocketMQ采用文件记录形式持久化。
    RocketMQ充分利用Linux文件系统内存cache来提高性能

消息可靠性
    影响消息可靠性的几种情况：
        Broker正常关闭
        Broker异常Crash
        OS Crash
        机器掉电，但是能立即恢复供电情况。
        机器无法开机（可能是cpu、主板、内存等关键设备损坏）
        磁盘设备损坏。

    (1)、(2)、(3)、(4)四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。

    (5)、(6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。
    RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。
    通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。

    RocketMQ从3.0版本开始支持同步双写。

低延迟消息分发
    在消息不堆积情况下，消息到达Broker后，能立刻到达Consumer。
    RocketMQ使用长轮询Pull方式，可保证消息非常实时，消息实时性不低于Push。






TODO:
    长轮询pull是什么鬼？
    https://www.2cto.com/kf/201802/723267.html
    Long Polling长轮询
    https://www.jianshu.com/p/d3f66b1eb748?from=timeline&isappinstalled=0

    
