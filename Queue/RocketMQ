MQ的核心理念：异步解耦、削峰填谷

特性：
===============================================
发布订阅

消息优先级（变通的方式）
    优先级高的队列、优先级中的队列、优先级低的队列、...根据实际需要定若干个级别
    每个优先级可以用不同的topic表示，发消息时，指定不同的topic来表示优先级，这种方式可以解决绝大部分的优先级问题，但是对业务的优先级精确性做了妥协。

消息顺序性

消息过滤
    服务端过滤
        根据消息类型、语法表达式、Message Tag、Message Header、Message body等方式进行过滤。但会增加服务端负担

    客户端过滤
        由应用自定义实现,但会多收无用消息

消息持久化
    几种持久化方式：
        持久化到数据库，例如Mysql。
        持久化到KV存储，例如levelDB、伯克利DB等KV存储系统。
        文件记录形式持久化，例如Kafka，RocketMQ
        对内存数据做一个持久化镜像，例如beanstalkd，VisiNotify
    分析：
        (1)、(2)、(3)三种持久化方式都具有将内存队列Buffer进行扩展的能力，
        (4)只是一个内存的镜像，作用是当Broker挂掉重启后仍然能将之前内存的数据恢复出来。

    RocketMQ采用文件记录形式持久化。
    RocketMQ充分利用Linux文件系统内存cache来提高性能

消息可靠性
    影响消息可靠性的几种情况：
        Broker正常关闭
        Broker异常Crash
        OS Crash
        机器掉电，但是能立即恢复供电情况。
        机器无法开机（可能是cpu、主板、内存等关键设备损坏）
        磁盘设备损坏。

    (1)、(2)、(3)、(4)四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。

    (5)、(6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。
    RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。
    通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。
    RocketMQ从3.0版本开始支持同步双写。

低延迟消息分发
    在消息不堆积情况下，消息到达Broker后，能立刻到达Consumer。
    RocketMQ使用长轮询Pull方式，可保证消息非常实时，消息实时性不低于Push。

至少投递一次
    RocketMQ Consumer先pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。

精准投递一次
    定义
        发送消息阶段，不允许发送重复的消息。
        消费消息阶段，不允许消费重复的消息。
        只有以上两个条件都满足，才认为消息是“精准投递一次”。
    实现
        RocketMQ并未实现该功能（因为分布式环境下很难做到这一点，而且开销巨大，因此为了高性能则放弃了此特性）。
        此问题的本质原因是网络调用存在不确定性，即既不成功也不失败的第三种状态，所以才产生了消息重复性问题。
        RocketMQ依然采用变通的方式：要求业务接口实现幂等，这样即可优雅解决重复消息的问题。

队列buffer
    RocketMQ没有内存Buffer概念，RocketMQ的队列都是持久化磁盘，数据定期清除。
    对于此问题的解决思路，RocketMQ同其他MQ有非常显著的区别，RocketMQ的内存Buffer抽象成一个无限长度的队列，不管有多少数据进来都能装得下，
    这个无限是有前提的，Broker会定期删除过期的数据，例如Broker只保存3天的消息，那么这个Buffer虽然长度无限，但是3天前的数据会被从队尾删除。

回溯消费
    回溯消费是指Consumer已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留。
    并且重新消费一般是按照时间维度，例如由于Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度来回退消费进度。
    RocketMQ支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯。

消息堆积
    消息中间件的主要功能是异步解耦，还有个重要功能是挡住前端的数据洪峰，保证后端系统的稳定性，这就要求消息中间件具有一定的消息堆积能力，消息堆积分以下两种情况：
        消息堆积在内存Buffer，一旦超过内存Buffer，可以根据一定的丢弃策略来丢弃消息，如CORBA Notification规范中描述。
            适合能容忍丢弃消息的业务，这种情况消息的堆积能力主要在于内存Buffer大小，而且消息堆积后，性能下降不会太大，因为内存中数据多少对于对外提供的访问能力影响有限。
        消息堆积到持久化存储系统中，例如DB，KV存储，文件记录形式。 
            当消息不能在内存Cache命中时，要不可避免的访问磁盘，会产生大量读IO，读IO的吞吐量直接决定了消息堆积后的访问能力。
    评估消息堆积能力主要有以下四点：
        消息能堆积多少条，多少字节？即消息的堆积容量。
        消息堆积后，发消息的吞吐量大小，是否会受堆积影响？
        消息堆积后，正常消费的Consumer是否会受影响？
        消息堆积后，访问堆积在磁盘的消息时，吞吐量有多大？

分布式事务
    已知的几个分布式事务规范，如XA，JTA等。其中XA规范被各大数据库厂商广泛支持，如Oracle，Mysql等。其中XA的TM实现佼佼者如Oracle Tuxedo，在金融、电信等领域被广泛应用。
    分布式事务涉及到两阶段提交问题，在数据存储方面的方面必然需要KV存储的支持，因为第二阶段的提交回滚需要修改消息状态，一定涉及到根据Key去查找Message的动作。
    RocketMQ在第二阶段绕过了根据Key去查找Message的问题，采用第一阶段发送Prepared消息时，拿到了消息的Offset，第二阶段通过Offset去访问消息，并修改状态，Offset就是数据的地址。
    RocketMQ这种实现事务方式，没有通过KV存储做，而是通过Offset方式，存在一个显著缺陷，即通过Offset更改数据，会令系统的脏页过多，需要特别关注。

定时消息
    延迟特定的时间点之后再消费

消息重试
    消息消费失败后，要提供一种重试机制，令消息再消费一次。

RocketMQ部署结构：
    NameServer+Broker（Master+Slave）
    数据与索引分离


========================================================================================================
消息收发模式进化：
    1.推模式
        低延迟
        但是无法按需消费
    2.长连接拉模式(长轮询Pull)    
        实时性依然得到保障
        可以按需消费
    3.以长轮询Pull为主，推为辅，两者结合的方式
        核心其实还是第2种
        

