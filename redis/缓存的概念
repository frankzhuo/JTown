缓存的使用场景：
    数据访问频率
        访问频率高
            适合缓存，效果好
        访问频率低
            不建议缓存，效果不佳
    数据读写比例
        读多写少
            适合缓存，效果好
        读少写多
            不建议缓存，效果不佳 
    数据一致性
        一致性要求低
             适合缓存，效果好
        一致性要求高
            不建议缓存，效果不佳

缓存使用场景总结：
    数据访问频率高、读多写少、对数据实时性要求不是太敏感的数据，适合缓存。否则，均不建议缓存，因为总体来看效果不佳。

不建议使用缓存的场景：
    对于（准）实时系统，不能用缓存，因为缓存会带来更多的麻烦。
    
几种缓存问题：

    缓存穿透
        定义：
            查询一个一定不存在的数据，由于缓存不命中，并且出于容错考虑， 如果从存储层查不到数据则不写入缓存。
            这将导致这个不存在的数据每次请求都要到存储层去查询，若这一点被黑客利用，那么DB极容易瞬间挂掉。
        危害：
            DB挂掉，服务崩溃。
        如何发现：
            监控
                分别记录总调用量、cache命中数、storage命中数。
                统计cache命中率。
                若发现空命中（cache,storage都没有命中）较多，就可能存在缓存穿透问题。

        解决方案：
            1.bloomFilter过滤（guava中有实现BloomFilter算法）
                原理：
                    将已存在的缓存放到bloomFilter中。由于bloomFilter出色的存储性能和查询性能，当黑客访问不存在的缓存时即可迅速返回，避免缓存及DB挂掉。
                适用场景：
                    1.数据命中不高
                    2.数据相对固定，实时性低                
                维护成本：
                    1.代码维护复杂
                    2.缓存空间占用少
            2.缓存空对象（可以设置一个较短的过期时间，缓解缓存空间被过多占用的问题）
                原理：
                    这样可以有效避免因结果为空值导致的不缓存，进而导致DB挂掉。
                适用场景：
                    1.数据命中不高
                    2.数据频繁变化，实时性高
                维护成本：                
                    1.代码维护简单
                    2.需要过多的缓存空间
                    3.数据不一致（？）

    缓存雪崩
        定义：
            若大量缓存的失效时间相同，并且这些缓存同时失效，那么所有系统的请求都会发送到DB层，造成DB瞬间压力过大，导致雪崩效应。
        解决方案：
            1.交错失效时间
                例如每次设置缓存过期时间时随机增加0-180秒，避免缓存同时过期，这样既可完美避开这个问题。
                简单而有效的解决方案。
            2.线程互斥
                只让一个线程构建缓存。
                不建议使用，因为增加了等待时间，提高了代码的复杂性，降低了系统的qps。

    缓存击穿
        定义：
            单点缓存过期时瞬间大量请求过来，导致DB压力过大。
            击穿与雪崩的区别即在于：击穿是对于某一特定的热点数据来说，而雪崩是全部数据。
        解决方案：
            利用分布式锁，保证集群中同时只有1个节点针对该热点数据查DB。


缓存的使用场景：
    针对业务系统，永远都是具体情况具体分析，没有最好，只有最合适。

    